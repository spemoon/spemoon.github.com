<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="人在江湖漂">
<meta property="og:url" content="http://yoursite.com/archives/index.html">
<meta property="og:site_name" content="人在江湖漂">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="人在江湖漂">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/archives/"/>





  <title>人在江湖漂</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">人在江湖漂</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            

            
              首页
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            

            
              归档
            

          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2012/02/14/javascript-memory-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2012/02/14/javascript-memory-analysis/" itemprop="url">由一个题目说到javascript的内存分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2012-02-14T00:00:00+08:00">2012-02-14</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天在群里看到一个前端的兄弟发了一个问题，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var A = function() &#123;&#125;</span><br><span class="line">    A.prototype = &#123;</span><br><span class="line">        //在仅改变这里的代码的情况下，能否使console.log(a2.b.c);结果为1</span><br><span class="line">        b : &#123;</span><br><span class="line">            c : 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var a1 = new A();</span><br><span class="line">    var a2 = new A();</span><br><span class="line">    a1.b.c = 2;</span><br><span class="line">    console.log(a2.b.c);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>对于这个问题，我还真没法在仅修改 b : { c : 1 } 的情况下使结果为1。</p>
<p>在未改动代码的情况下，console.log(a2.b.c);的结果是2。</p>
<p>如果不明白，那我们来看看javascript的内存分配吧：</p>
<h3 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h3><p>在ECMAScript中，变量可以存放原始值和引用值。</p>
<p>原始值，如Number, String, Boolean, Null, Undefined。 指的是代表原始数据类型，即基本数据类型，的值。</p>
<p>引用值，如Object, Function, Array, 以及自定义对象等。指的是复合数据类型的值。</p>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>简单的说，原始值放在内存中叫栈的地方，而引用值则放在堆中。</p>
<p>原始值是存储在栈中的简单数据段，也就是说，他们的值直接存储在变量访问的位置。</p>
<p>堆是存放数据的基于 散列算法 的 数据结构，也就是说，存储在变量处的值(即指向对象的变量，存储在栈中)是一个指针，指向存储在堆中的实际对象。</p>
<p>例：var obj = new Object(); obj 存储在栈中，它指向于 new Object()这个对象，而new Object()是存放在堆中的。</p>
<p>下面我们来看一个具体的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(id,name,age)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var num = 10;</span><br><span class="line">var bool = true;</span><br><span class="line">var str = &quot;abc&quot;;</span><br><span class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">var obj = new Object();</span><br><span class="line">var person = new Person(001,&quot;spemoon&quot;,24);</span><br></pre></td></tr></table></figure>
<p>然后我们来看一下内存分析图：</p>
<p><img src="../images/content/memory.png" alt="内存分析" title="内存分析"></p>
<p>变量num,bol,str为基本数据类型，它们的值，直接存放在栈中，obj,person,arr为复合数据类型，他们的引用变量存储在栈中，指向于存储在堆中的实际对象。</p>
<p>由上图可知，我们无法直接操纵堆中的数据，也就是说我们无法直接操纵对象，但我们可以通过栈中对对象的引用来操作对象。</p>
<p>那为什么引用值要放在堆中，而原始值要放在栈中呢？</p>
<p>堆比栈大，栈比堆的运算速度快，对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 </p>
<p>现在再让我们回过头来看开始的那个题目：</p>
<p>a1.b.c 这里是指向一个对象，即是堆中的一个引用值，故对其赋值，则会修改堆中的对象的引用，结果会使a2.b.c == 2。</p>
<p>如果上述代码这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var A = function() &#123;&#125;</span><br><span class="line">    A.prototype = &#123;</span><br><span class="line">        b : 1</span><br><span class="line">    &#125;</span><br><span class="line">    var a1 = new A();</span><br><span class="line">    var a2 = new A();</span><br><span class="line">    a1.b = 2;</span><br><span class="line">    console.log(a2.b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>那么a2.b的结果是1，因为对于栈中的原始值，在进行赋值的过程中，其实是为a1新建了一个a1.b，并没有影响到A的原型上的b的值。</p>
<p>再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;;   </span><br><span class="line">a.prototype.xx=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];  </span><br><span class="line">var a1 = new a();   </span><br><span class="line">var a2 = new a();   </span><br><span class="line">var a3 = new a();</span><br><span class="line">a1.xx = [&apos;a&apos;];  </span><br><span class="line">a3.xx.push(12);</span><br></pre></td></tr></table></figure>
<p>那现在a1.xx,a2.xx和a3.xx分别是多少？</p>
<p>结果是：a1.xx = [‘a’],a2.xx = [‘a’,’b’,’c’,12],a3.xx = [‘a’,’b’,’c’,12]</p>
<p>由于数组是高级javascript对象，因此func a()的实例对象中的xx属性值都是引用到同一个地方的。当a1.xx = [‘a’]时实际上是新建了一个数组然后把引用给了a1.xx属性。</p>
<p>对于a.prototype.xx 是没有影响的。而a3.xx.push(12)才会真正操作了a的prototype上面的xx，因此a2.xx也跟着改变了。</p>
<p>总结：实际上，在开发过程中，不推荐将不想被实例对象共享的属性还是放到prototype中。对于属性还是放在构造器中好些，对于一些公共的方法可以放在原型上。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/18/front-end-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/18/front-end-optimization/" itemprop="url">前端开发的优化问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-18T00:00:00+08:00">2011-12-18</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/fe/" itemprop="url" rel="index">
                    <span itemprop="name">fe</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>减少http请求次数：css spirit,data uri</li>
<li>JS，CSS源码压缩</li>
<li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</li>
<li>用setTimeout来避免页面失去响应</li>
<li>用hash-table来优化查找</li>
<li>当需要设置的样式很多时设置className而不是直接操作style</li>
<li>少用全局变量</li>
<li>缓存DOM节点查找的结果</li>
<li>避免使用CSS Expression</li>
<li>图片预载</li>
<li>避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/15/nodejs-note-crypto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/15/nodejs-note-crypto/" itemprop="url">Node.js学习笔记——Crypto 加密模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-15T00:00:00+08:00">2011-12-15</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index">
                    <span itemprop="name">node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用require(‘crypto’)调用加密模块。</p>
<p>加密模块需要底层系统提供OpenSSL的支持。它提供了一种安全凭证的封装方式，可以用于HTTPS安全网络以及普通HTTP连接。</p>
<p>该模块还提供了一套针对OpenSSL的hash（哈希），hmac（密钥哈希），cipher（编码），decipher（解码），sign（签名）以及verify（验证）等方法的封装。</p>
<h3 id="crypto-createCredentials-details"><a href="#crypto-createCredentials-details" class="headerlink" title="crypto.createCredentials(details)"></a>crypto.createCredentials(details)</h3><p>创建一个凭证对象，可选参数details为一个带键值的字典：</p>
<ul>
<li><p>key：为字符串型，PEM编码的私钥。</p>
</li>
<li><p>cert：为字符串型，PEM编码的认证证书。</p>
</li>
<li><p>ca：字符串形式的PEM编码可信CA证书，或证书列表。</p>
</li>
</ul>
<p>如果没有给出’ca’的详细内容，那么node.js将会使用默认的公开受信任列表，该表位于<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>。</p>
<h3 id="crypto-createHash-algorithm"><a href="#crypto-createHash-algorithm" class="headerlink" title="crypto.createHash(algorithm)"></a>crypto.createHash(algorithm)</h3><p>创建并返回一个hash对象，它是一个指定算法的加密hash，用于生成hash摘要。</p>
<p>参数algorithm可选择系统上安装的OpenSSL版本所支持的算法。例如：’sha1’, ‘md5’, ‘sha256’, ‘sha512’等。在近期发行的版本中，openssl list-message-digest-algorithms会显示这些可用的摘要算法。</p>
<h3 id="hash-update-data"><a href="#hash-update-data" class="headerlink" title="hash.update(data)"></a>hash.update(data)</h3><p>更新hash的内容为指定的data。当使用流数据时可能会多次调用该方法。</p>
<h3 id="hash-digest-encoding-’binary’"><a href="#hash-digest-encoding-’binary’" class="headerlink" title="hash.digest(encoding=’binary’)"></a>hash.digest(encoding=’binary’)</h3><p>计算所有传入数据的hash摘要。参数encoding（编码方式）可以为’hex’, ‘binary’ 或者’base64’。</p>
<h3 id="crypto-createHmac-algorithm-key"><a href="#crypto-createHmac-algorithm-key" class="headerlink" title="crypto.createHmac(algorithm, key)"></a>crypto.createHmac(algorithm, key)</h3><p>创建并返回一个hmac对象，它是一个指定算法和密钥的加密hmac。</p>
<p>参数algorithm可选择OpenSSL支持的算法 - 参见上文的createHash。参数key为hmac所使用的密钥。</p>
<h3 id="hmac-update-data"><a href="#hmac-update-data" class="headerlink" title="hmac.update(data)"></a>hmac.update(data)</h3><p>更新hmac的内容为指定的data。当使用流数据时可能会多次调用该方法。</p>
<h3 id="hmac-digest-encoding-’binary’"><a href="#hmac-digest-encoding-’binary’" class="headerlink" title="hmac.digest(encoding=’binary’)"></a>hmac.digest(encoding=’binary’)</h3><p>计算所有传入数据的hmac摘要。参数encoding（编码方式）可以为’hex’, ‘binary’ 或者’base64’。</p>
<h3 id="crypto-createCipher-algorithm-key"><a href="#crypto-createCipher-algorithm-key" class="headerlink" title="crypto.createCipher(algorithm, key)"></a>crypto.createCipher(algorithm, key)</h3><p>使用指定的算法和密钥创建并返回一个cipher对象。</p>
<p>参数algorithm可选择OpenSSL支持的算法，例如’aes192’等。在最近的发行版中，openssl list-cipher-algorithms会显示可用的加密的算法。</p>
<h3 id="cipher-update-data-input-encoding-’binary’-output-encoding-’binary’"><a href="#cipher-update-data-input-encoding-’binary’-output-encoding-’binary’" class="headerlink" title="cipher.update(data, input_encoding=’binary’, output_encoding=’binary’)"></a>cipher.update(data, input_encoding=’binary’, output_encoding=’binary’)</h3><p>使用参数data更新要加密的内容，其编码方式由参数input_encoding指定，可以为 ‘utf8’, ‘ascii’或者’binary’。参数output_encoding指定了已加密内容的输出编码方式，可以为 ‘binary’, ‘base64’或’hex’。</p>
<p>返回已加密的内容，当使用流数据时可能会多次调用该方法。</p>
<h3 id="cipher-final-output-encoding-’binary’"><a href="#cipher-final-output-encoding-’binary’" class="headerlink" title="cipher.final(output_encoding=’binary’)"></a>cipher.final(output_encoding=’binary’)</h3><p>返回所有剩余的加密内容，output_encoding输出编码为’binary’, ‘ascii’或’utf8’其中之一。</p>
<h3 id="crypto-createDecipher-algorithm-key"><a href="#crypto-createDecipher-algorithm-key" class="headerlink" title="crypto.createDecipher(algorithm, key)"></a>crypto.createDecipher(algorithm, key)</h3><p>使用给定的算法和密钥创建并返回一个解密对象。该对象为上述加密对象的反向运算。</p>
<h3 id="decipher-update-data-input-encoding-’binary’-output-encoding-’binary’"><a href="#decipher-update-data-input-encoding-’binary’-output-encoding-’binary’" class="headerlink" title="decipher.update(data, input_encoding=’binary’, output_encoding=’binary’)"></a>decipher.update(data, input_encoding=’binary’, output_encoding=’binary’)</h3><p>使用参数data更新要解密的内容，其编码方式为’binary’，’base64’或’hex’。参数output_encoding指定了已解密的明文内容的输出编码方式，可以为 ‘binary’，’ascii’或’utf8’。</p>
<h3 id="decipher-final-output-encoding-’binary’"><a href="#decipher-final-output-encoding-’binary’" class="headerlink" title="decipher.final(output_encoding=’binary’)"></a>decipher.final(output_encoding=’binary’)</h3><p>返回全部剩余的已解密的明文，其output_encoding’ 为’binary’, ‘ascii’或’utf8’`其中之一。</p>
<h3 id="crypto-createSign-algorithm"><a href="#crypto-createSign-algorithm" class="headerlink" title="crypto.createSign(algorithm)"></a>crypto.createSign(algorithm)</h3><p>使用给定的算法创建并返回一个签名器对象。在现有的OpenSSL发行版中，openssl list-public-key-algorithms会显示可用的签名算法，例如：’RSA-SHA256’。</p>
<h3 id="signer-update-data"><a href="#signer-update-data" class="headerlink" title="signer.update(data)"></a>signer.update(data)</h3><p>使用data参数更新签名器对象。当使用流数据时可能会多次调用该方法。</p>
<h3 id="signer-sign-private-key-output-format-’binary’"><a href="#signer-sign-private-key-output-format-’binary’" class="headerlink" title="signer.sign(private_key, output_format=’binary’)"></a>signer.sign(private_key, output_format=’binary’)</h3><p>对所有传入签名器的数据计算其签名。private_key为字符串，它包含了PEM编码的用于签名的私钥。</p>
<p>返回签名，其output_format输出可以为’binary’, ‘hex’ 或者’base64’。</p>
<h3 id="crypto-createVerify-algorithm"><a href="#crypto-createVerify-algorithm" class="headerlink" title="crypto.createVerify(algorithm)"></a>crypto.createVerify(algorithm)</h3><p>使用给定算法创建并返回一个验证器对象。它是上述签名器对象的反向运算。</p>
<h3 id="verifier-update-data"><a href="#verifier-update-data" class="headerlink" title="verifier.update(data)"></a>verifier.update(data)</h3><p>使用data参数更新验证器对象。当使用流数据时可能会多次调用该方法。</p>
<h3 id="verifier-verify-cert-signature-signature-format-’binary’"><a href="#verifier-verify-cert-signature-signature-format-’binary’" class="headerlink" title="verifier.verify(cert, signature, signature_format=’binary’)"></a>verifier.verify(cert, signature, signature_format=’binary’)</h3><p>使用参数cert和signature验证已签名的数据，cert为经过PEM编码的公钥字符串，signature为之前已计算的数据的签名，signature_format可以为’binary’，’hex’ 或者’base64’。</p>
<p>根据对数据和公钥进行签名有效性验证的结果，返回true或者false。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/14/nodejs-note-streams/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/14/nodejs-note-streams/" itemprop="url">Node.js学习笔记——Streams 流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-14T00:00:00+08:00">2011-12-14</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index">
                    <span itemprop="name">node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Node中，Stream（流）是一个由不同对象实现的抽象接口。例如请求HTTP服务器的request是一个流，类似于stdout（标准输出）。流可以是可读的，可写的，或者既可读又可写。所有流都是EventEmitter的实例。</p>
<h2 id="Readable-Stream-可读流"><a href="#Readable-Stream-可读流" class="headerlink" title="Readable Stream 可读流"></a>Readable Stream 可读流</h2><p>一个可读流具有下述的方法、成员、及事件。</p>
<h3 id="Event-‘data’-事件：’data’"><a href="#Event-‘data’-事件：’data’" class="headerlink" title="Event: ‘data’ 事件：’data’"></a>Event: ‘data’ 事件：’data’</h3><p>function (data) { }</p>
<p>‘data’事件的回调函数参数默认情况下是一个Buffer对象。如果使用了setEncoding() 则参数为一个字符串。</p>
<h3 id="Event-‘end’-事件：’end’"><a href="#Event-‘end’-事件：’end’" class="headerlink" title="Event: ‘end’ 事件：’end’"></a>Event: ‘end’ 事件：’end’</h3><p>function () { }</p>
<p>当流中接收到EOF（TCP中为FIN）时此事件被触发，表示流的读取已经结束，不会再发生任何’data’事件。如果流同时也是可写的，那它还可以继续写入。</p>
<h3 id="Event-‘error’-事件：’error’"><a href="#Event-‘error’-事件：’error’" class="headerlink" title="Event: ‘error’ 事件：’error’"></a>Event: ‘error’ 事件：’error’</h3><p>function (exception) { }</p>
<p>接收数据的过程中发生任何错误时，此事件被触发。</p>
<h3 id="Event-‘close’-事件：’close’"><a href="#Event-‘close’-事件：’close’" class="headerlink" title="Event: ‘close’ 事件：’close’"></a>Event: ‘close’ 事件：’close’</h3><p>function () { }</p>
<p>当底层的文件描述符被关闭时触发此事件，并不是所有流都会触发这个事件。（例如，一个连接进入的HTTP request流就不会触发’close’事件。）</p>
<h3 id="Event-‘fd’-事件：’fd’"><a href="#Event-‘fd’-事件：’fd’" class="headerlink" title="Event: ‘fd’ 事件：’fd’"></a>Event: ‘fd’ 事件：’fd’</h3><p>function (fd) { }</p>
<p>当在流中接收到一个文件描述符时触发此事件。只有UNIX流支持这个功能，其他类型的流均不会触发此事件。</p>
<h3 id="stream-readable"><a href="#stream-readable" class="headerlink" title="stream.readable"></a>stream.readable</h3><p>这是一个布尔值，默认值为true。当’error’事件或’end’事件发生后，或者destroy()被调用后，这个属性将变为false。</p>
<h3 id="stream-setEncoding-encoding"><a href="#stream-setEncoding-encoding" class="headerlink" title="stream.setEncoding(encoding)"></a>stream.setEncoding(encoding)</h3><p>调用此方法会影响’data’事件的回调函数参数形式，默认为Buffer对象，调用此方法后为字符串。encoding参数可以是’utf8’、’ascii’、或’base64’。</p>
<h3 id="stream-pause"><a href="#stream-pause" class="headerlink" title="stream.pause()"></a>stream.pause()</h3><p>暂停’data’事件的触发。</p>
<h3 id="stream-resume"><a href="#stream-resume" class="headerlink" title="stream.resume()"></a>stream.resume()</h3><p>恢复被pause()调用暂停的’data’事件触发。</p>
<h3 id="stream-destroy"><a href="#stream-destroy" class="headerlink" title="stream.destroy()"></a>stream.destroy()</h3><p>关闭底层的文件描述符。流上将不会再触发任何事件。</p>
<h3 id="stream-destroySoon"><a href="#stream-destroySoon" class="headerlink" title="stream.destroySoon()"></a>stream.destroySoon()</h3><p>在写队列清空后（所有写操作完成后），关闭文件描述符。</p>
<h3 id="stream-pipe-destination-options"><a href="#stream-pipe-destination-options" class="headerlink" title="stream.pipe(destination, [options])"></a>stream.pipe(destination, [options])</h3><p>这是Stream.prototype（Stream原型对象）的一个方法，对所有Stream对象有效。</p>
<p>用于将这个可读流和destination目标可写流连接起来，传入这个流中的数据将会写入到destination流中。通过在必要时暂停和恢复流，来源流和目的流得以保持同步。</p>
<p>模拟Unix系统的cat命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.resume();</span><br><span class="line">process.stdin.pipe(process.stdout);</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，当来源流的end事件触发时目的流的end()方法会被调用，此时destination目的流将不再可写入。要在这种情况下为了保持目的流仍然可写入，可将options参数设为{ end: false }。</p>
<p>这使process.stdout保持打开状态，因此”Goodbye”可以在end事件发生后被写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.resume();</span><br><span class="line"></span><br><span class="line">process.stdin.pipe(process.stdout, &#123; end: false &#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.on(&quot;end&quot;, function() &#123;</span><br><span class="line">    process.stdout.write(&quot;Goodbye\n&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：如果来源流不支持pause()和resume()方法，此函数将在来源流对象上增加这两个方法的简单定义，内容为触发’pause’和’resume’事件。</p>
<h2 id="Writable-Stream-可写流"><a href="#Writable-Stream-可写流" class="headerlink" title="Writable Stream 可写流"></a>Writable Stream 可写流</h2><p>一个可写流具有下列方法、成员、和事件。</p>
<h3 id="Event-‘drain’-事件：’drain’"><a href="#Event-‘drain’-事件：’drain’" class="headerlink" title="Event: ‘drain’ 事件：’drain’"></a>Event: ‘drain’ 事件：’drain’</h3><p>function () { }</p>
<p>发生在write()方法被调用并返回false之后。此事件被触发说明内核缓冲区已空，再次写入是安全的。</p>
<h3 id="Event-‘error’-事件：’error’-1"><a href="#Event-‘error’-事件：’error’-1" class="headerlink" title="Event: ‘error’ 事件：’error’"></a>Event: ‘error’ 事件：’error’</h3><p>function (exception) { }</p>
<p>发生错误时被触发，回调函数接收一个异常参数exception。</p>
<h3 id="Event-‘close’-事件：’close’-1"><a href="#Event-‘close’-事件：’close’-1" class="headerlink" title="Event: ‘close’ 事件：’close’"></a>Event: ‘close’ 事件：’close’</h3><p>function () { }</p>
<p>底层文件描述符被关闭时被触发。</p>
<h3 id="Event-‘pipe’-事件：’pipe’"><a href="#Event-‘pipe’-事件：’pipe’" class="headerlink" title="Event: ‘pipe’ 事件：’pipe’"></a>Event: ‘pipe’ 事件：’pipe’</h3><p>function (src) { }</p>
<p>当此可写流作为参数传给一个可读流的pipe方法时被触发。</p>
<h3 id="stream-writable"><a href="#stream-writable" class="headerlink" title="stream.writable"></a>stream.writable</h3><p>一个布尔值，默认值为true。在’error’事件被触发之后，或end() / destroy()方法被调用后此属性被设为false。</p>
<h3 id="stream-write-string-encoding-’utf8’-fd"><a href="#stream-write-string-encoding-’utf8’-fd" class="headerlink" title="stream.write(string, encoding=’utf8’, [fd])"></a>stream.write(string, encoding=’utf8’, [fd])</h3><p>使用指定编码encoding将字符串string写入到流中。如果字符串被成功写入内核缓冲区，此方法返回true。如果内核缓冲区已满，此方法返回false，数据将在以后被送出。当内核缓冲区再次被清空后’drain’事件将被触发。encoding参数默认为’utf8’`。</p>
<p>如果指定了可选参数fd，它将被作为一个文件描述符通过流传送。此功能仅被Unix流所支持，对于其他流此操作将被忽略而没有任何提示。当使用此方法传送一个文件描述符时，如果在流没有清空前关闭此文件描述符，将造成传送一个无效（已关闭）FD的风险。</p>
<h3 id="stream-write-buffer"><a href="#stream-write-buffer" class="headerlink" title="stream.write(buffer)"></a>stream.write(buffer)</h3><p>除了用一个Buffer对象替代字符串之外，其他同上。</p>
<h3 id="stream-end"><a href="#stream-end" class="headerlink" title="stream.end()"></a>stream.end()</h3><p>使用EOF或FIN结束一个流的输出。</p>
<h3 id="stream-end-string-encoding"><a href="#stream-end-string-encoding" class="headerlink" title="stream.end(string, encoding)"></a>stream.end(string, encoding)</h3><p>以指定的字符编码encoding传送一个字符串string，然后使用EOF或FIN结束流的输出。这对降低数据包传输量有所帮助。</p>
<h3 id="stream-end-buffer"><a href="#stream-end-buffer" class="headerlink" title="stream.end(buffer)"></a>stream.end(buffer)</h3><p>除了用一个buffer对象替代字符串之外，其他同上。</p>
<h3 id="stream-destroy-1"><a href="#stream-destroy-1" class="headerlink" title="stream.destroy()"></a>stream.destroy()</h3><p>关闭底层文件描述符。在此流上将不会再触发任何事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/13/nodejs-note-buffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/13/nodejs-note-buffers/" itemprop="url">Node.js学习笔记——Buffers 缓冲器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-13T00:00:00+08:00">2011-12-13</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index">
                    <span itemprop="name">node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>纯Javascript语言是Unicode友好性的，但是难以处理二进制数据。在处理TCP流和文件系统时经常需要操作字节流。Node提供了一些列机制，用于操作、创建、以及消耗（consuming）字节流。</p>
<p>在实例化的Buffer类中存储了原始数据。Buffer类似于一个整数数组，但Buffer对应了在V8堆（the V8 heap）外的原始存储空间分配。一旦创建了Buffer实例，则无法改变其大小。</p>
<p>另外，Buffer是一个全局对象。</p>
<p>在缓冲器（Buffers）和JavaScript间进行字符串的转换需要调用特定的编码方法。如下列举了不同的编码方法：</p>
<ul>
<li><p>‘ascii’ - 仅对应7位的ASCII数据。虽然这种编码方式非常迅速，并且如果设置了最高位，则会将其移去。</p>
</li>
<li><p>‘utf8’ - 对应多字节编码Unicode字符。大量网页和其他文件格式使用这类编码方式。</p>
</li>
<li><p>‘ucs2’ - 2字节的，低字节序编码Unicode字符。只能编码BMP（第零平面，U+0000 - U+FFFF）字符。</p>
</li>
<li><p>‘base64’ - Base64 字符串编码.</p>
</li>
<li><p>‘binary’ - 仅使用每个字符的头8位将原始的二进制信息进行编码。在需使用Buffer的情况下，应该尽量避免使用这个已经过时的编码方式。而且，这个编码方式不会出现在未来版本的Node中。</p>
</li>
<li><p>‘hex’ - 将一个字节编码为两个16进制字符。</p>
</li>
</ul>
<h3 id="new-Buffer-size"><a href="#new-Buffer-size" class="headerlink" title="new Buffer(size)"></a>new Buffer(size)</h3><p>使用array的空间创建一个buffer实例。</p>
<h3 id="new-Buffer-str-encoding-’utf8’"><a href="#new-Buffer-str-encoding-’utf8’" class="headerlink" title="new Buffer(str, encoding=’utf8’)"></a>new Buffer(str, encoding=’utf8’)</h3><p>创建一个包含给定str的buffer实例。</p>
<h3 id="buffer-write-string-offset-0-encoding-’utf8’"><a href="#buffer-write-string-offset-0-encoding-’utf8’" class="headerlink" title="buffer.write(string, offset=0, encoding=’utf8’)"></a>buffer.write(string, offset=0, encoding=’utf8’)</h3><p>通过给定的编码方式把string写入到buffer的offset（偏移地址）中，并且返回写入的字节数。如果当前的buffer没有足够存储空间，字符串会部分地保存在buffer中，而不是整串字符。需要注意的是，如果使用’utf8’进行编码，该方法不会对零散的字符进行编写。</p>
<p>例如：将一串utf8格式的字符串写入Buffer，然后输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="keyword">new</span> Buffer(<span class="number">256</span>);</span><br><span class="line">len = buf.write(<span class="string">'\u00bd + \u00bc = \u00be'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(len + <span class="string">" bytes: "</span> + buf.toString(<span class="string">'utf8'</span>, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 12 bytes: ½ + ¼ = ¾</span></span><br></pre></td></tr></table></figure></p>
<h3 id="buffer-toString-encoding-start-0-end-buffer-length"><a href="#buffer-toString-encoding-start-0-end-buffer-length" class="headerlink" title="buffer.toString(encoding, start=0, end=buffer.length)"></a>buffer.toString(encoding, start=0, end=buffer.length)</h3><p>对缓冲器中的以encoding方式编码的，以start标识符开始，以end标识符结尾的缓冲数据进行解码，并输出字符串。</p>
<h3 id="buffer-index"><a href="#buffer-index" class="headerlink" title="buffer[index]"></a>buffer[index]</h3><p>获取或者设置位于index字节的值。由于返回值为单个的字节，因此其范围应该在0x00 到 0xFF（16进制）或者0 and 255（10进制）之间</p>
<p>例如：通过每次仅输入一个字符的方式将整串ASCII字符录入Buffer中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"node.js"</span>;</span><br><span class="line">buf = <span class="keyword">new</span> Buffer(str.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length ; i++) &#123;</span><br><span class="line">    buf[i] = str.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node.js</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Buffer-isBuffer-obj"><a href="#Buffer-isBuffer-obj" class="headerlink" title="Buffer.isBuffer(obj)"></a>Buffer.isBuffer(obj)</h3><p>验证obj的类别是否为Buffer类。</p>
<h3 id="Buffer-byteLength-string-encoding-’utf8’"><a href="#Buffer-byteLength-string-encoding-’utf8’" class="headerlink" title="Buffer.byteLength(string, encoding=’utf8’)"></a>Buffer.byteLength(string, encoding=’utf8’)</h3><p>返回字符串长度的实际值。与String.prototype.length的区别之处在于该方法返回的是字符串中characters的个数。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'\u00bd + \u00bc = \u00be'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str + <span class="string">": "</span> + str.length + <span class="string">" characters, "</span> +</span><br><span class="line">        Buffer.byteLength(str, <span class="string">'utf8'</span>) + <span class="string">" bytes"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ½ + ¼ = ¾: 9 characters, 12 bytes</span></span><br></pre></td></tr></table></figure></p>
<h3 id="buffer-length"><a href="#buffer-length" class="headerlink" title="buffer.length"></a>buffer.length</h3><p>返回Buffer占用的字节数。需要注意的是，length并非其内容占的大小，而是指分配给Buffer实例的存储空间的大小，因此该值不会随Buffer内容的变化而变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="keyword">new</span> Buffer(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf.length);</span><br><span class="line">buf.write(<span class="string">"some string"</span>, <span class="string">"ascii"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1234</span></span><br><span class="line"><span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>
<h3 id="buffer-copy-targetBuffer-targetStart-0-sourceStart-0-sourceEnd-buffer-length"><a href="#buffer-copy-targetBuffer-targetStart-0-sourceStart-0-sourceEnd-buffer-length" class="headerlink" title="buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)"></a>buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3><p>在两个Buffer之间进行memcpy() 操作。</p>
<p>例如：创建2个Buffer实例，然后将buf1中第16字节到第19字节间的信息复制到buf2中，并使在buf2中新的字符串首字符位于第8字节：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buf1 = <span class="keyword">new</span> Buffer(<span class="number">26</span>);</span><br><span class="line">buf2 = <span class="keyword">new</span> Buffer(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++) &#123;</span><br><span class="line">    buf1[i] = i + <span class="number">97</span>; <span class="comment">// 97 is ASCII a</span></span><br><span class="line">    buf2[i] = <span class="number">33</span>; <span class="comment">// ASCII !</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf1.copy(buf2, <span class="number">8</span>, <span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf2.toString(<span class="string">'ascii'</span>, <span class="number">0</span>, <span class="number">25</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// !!!!!!!!qrst!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure>
<h3 id="buffer-slice-start-end-buffer-length"><a href="#buffer-slice-start-end-buffer-length" class="headerlink" title="buffer.slice(start, end=buffer.length)"></a>buffer.slice(start, end=buffer.length)</h3><p>返回一个和原Buffer引用相同存储空间的新Buffer，但是新Buffer中的偏移地址截取了原Buffer偏移地址中自start到end的部分。</p>
<p>特别注意：通过修改新的Buffer切片（slice）中的内容同样会修改存储在原Buffer中的信息！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf1 = <span class="keyword">new</span> Buffer(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++) &#123;</span><br><span class="line">    buf1[i] = i + <span class="number">97</span>; <span class="comment">// 97 is ASCII a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf2 = buf1.slice(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf2.toString(<span class="string">'ascii'</span>, <span class="number">0</span>, buf2.length));</span><br><span class="line">buf1[<span class="number">0</span>] = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf2.toString(<span class="string">'ascii'</span>, <span class="number">0</span>, buf2.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// !bc</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/12/nodejs-note-events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/12/nodejs-note-events/" itemprop="url">Node.js学习笔记——Events 事件模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-12T00:00:00+08:00">2011-12-12</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index">
                    <span itemprop="name">node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Node引擎中很多对象都会触发事件：例如net.Server会在每一次有客户端连接到它时触发事件，又如fs.readStream会在文件打开时触发事件。所有能够触发事件的对象都是events.EventEmitter的实例。你可以通过require(“events”);访问这个模块。</p>
<p>通常情况下，事件名称采用驼峰式写法，不过目前并没有对事件名称作任何的限制，也就是说任何的字符串都可以被接受。</p>
<p>可以将函数注册给对象，使其在事件触发时执行，此类函数被称作监听器。</p>
<h3 id="events-EventEmitter"><a href="#events-EventEmitter" class="headerlink" title="events.EventEmitter"></a>events.EventEmitter</h3><p>通过调用require(‘events’).EventEmitter，我们可以使用事件触发器类。</p>
<p>当EventEmitter事件触发器遇到错误时，典型的处理方式是它将触发一个’error’事件。Error事件的特殊性在于：如果没有函数处理这个事件，它将会输出调用堆栈，并随之退出应用程序。</p>
<p>当新的事件监听器被添加时，所有的事件触发器都将触发名为’newListener’的事件。</p>
<h3 id="emitter-addListener-event-listener"><a href="#emitter-addListener-event-listener" class="headerlink" title="emitter.addListener(event, listener)"></a>emitter.addListener(event, listener)</h3><h3 id="emitter-on-event-listener"><a href="#emitter-on-event-listener" class="headerlink" title="emitter.on(event, listener)"></a>emitter.on(event, listener)</h3><p>将一个监听器添加到指定事件的监听器数组的末尾。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="emitter-once-event-listener"><a href="#emitter-once-event-listener" class="headerlink" title="emitter.once(event, listener)"></a>emitter.once(event, listener)</h3><p>为事件添加一次性的监听器。该监听器在事件第一次触发时执行，过后将被移除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.once(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Ah, we have our first user!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="emitter-removeListener-event-listener"><a href="#emitter-removeListener-event-listener" class="headerlink" title="emitter.removeListener(event, listener)"></a>emitter.removeListener(event, listener)</h3><p>将监听器从指定事件的监听器数组中移除出去。 小心：此操作将改变监听器数组的下标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">server.on(<span class="string">'connection'</span>, callback);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">server.removeListener(<span class="string">'connection'</span>, callback);</span><br></pre></td></tr></table></figure>
<h3 id="emitter-removeAllListeners-event"><a href="#emitter-removeAllListeners-event" class="headerlink" title="emitter.removeAllListeners(event)"></a>emitter.removeAllListeners(event)</h3><p>将指定事件的所有监听器从监听器数组中移除。</p>
<h3 id="emitter-setMaxListeners-n"><a href="#emitter-setMaxListeners-n" class="headerlink" title="emitter.setMaxListeners(n)"></a>emitter.setMaxListeners(n)</h3><p>默认情况下当事件触发器注册了超过10个以上的监听器时系统会打印警告信息，这个默认配置将有助于你查找内存泄露问题。很显然并不是所有的事件触发器都需要进行10个监听器的限制，此函数允许你手动设置该数量值，如果值为0意味值没有限制。</p>
<h3 id="emitter-listeners-event"><a href="#emitter-listeners-event" class="headerlink" title="emitter.listeners(event)"></a>emitter.listeners(event)</h3><p>返回指定事件的监听器数组对象，你可以对该数组进行操作，比如说删除监听器等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(server.listeners(<span class="string">'connection'</span>)); <span class="comment">// [ [Function] ]</span></span><br></pre></td></tr></table></figure>
<h3 id="emitter-emit-event-arg1-arg2-…"><a href="#emitter-emit-event-arg1-arg2-…" class="headerlink" title="emitter.emit(event, [arg1], [arg2], […])"></a>emitter.emit(event, [arg1], [arg2], […])</h3><p>以提供的参数作为监听器函数的参数，顺序执行监听器列表中的每个监听器函数。</p>
<h3 id="Event-‘newListener’"><a href="#Event-‘newListener’" class="headerlink" title="Event: ‘newListener’"></a>Event: ‘newListener’</h3><p>function (event, listener) { }</p>
<p>任何时候只要新的监听器被添加时该事件就会触发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/11/nodejs-note-util/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/11/nodejs-note-util/" itemprop="url">Node.js学习笔记——util 工具模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-11T00:00:00+08:00">2011-12-11</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index">
                    <span itemprop="name">node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下列函数属于’util’（工具）模块，可使用require(‘util’)访问它们。</p>
<h3 id="util-debug-string"><a href="#util-debug-string" class="headerlink" title="util.debug(string)"></a>util.debug(string)</h3><p>这是一个同步输出函数，将string参数的内容实时输出到stderr标准错误。调用此函数时将阻塞当前进程直到输出完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'util'</span>).debug(<span class="string">'message on stderr'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="util-log-string"><a href="#util-log-string" class="headerlink" title="util.log(string)"></a>util.log(string)</h3><p>将string参数的内容加上当前时间戳，输出到stdout标准输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'util'</span>).log(<span class="string">'Timestmaped message.'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="util-inspect-object-showHidden-false-depth-2"><a href="#util-inspect-object-showHidden-false-depth-2" class="headerlink" title="util.inspect(object, showHidden=false, depth=2)"></a>util.inspect(object, showHidden=false, depth=2)</h3><p>以字符串形式返回object对象的结构信息，这对程序调试非常有帮助。</p>
<p>如果showHidden参数设置为true，则此对象的不可枚举属性也会被显示。</p>
<p>可使用depth参数指定inspect函数在格式化对象信息时的递归次数。这对分析复杂对象的内部结构非常有帮助。</p>
<p>默认情况下递归两次，如果想要无限递归可将depth参数设为null。</p>
<p>显示util对象所有属性的例子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(util, <span class="literal">true</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure></p>
<h3 id="util-pump-readableStream-writableStream-callback"><a href="#util-pump-readableStream-writableStream-callback" class="headerlink" title="util.pump(readableStream, writableStream, [callback])"></a>util.pump(readableStream, writableStream, [callback])</h3><p>实验性的</p>
<p>从readableStream参数所指定的可读流中读取数据，并将其写入到writableStream参数所指定的可写流中。当writeableStream.write(data)函数调用返回为false时，readableStream流将被暂停，直到在writableStream流上发生drain事件。当writableStream流被关闭或发生一个错误时，callback回调函数被调用。此回调函数只接受一个参数用以指明所发生的错误。</p>
<h3 id="util-inherits-constructor-superConstructor"><a href="#util-inherits-constructor-superConstructor" class="headerlink" title="util.inherits(constructor, superConstructor)"></a>util.inherits(constructor, superConstructor)</h3><p>将一个构造函数的原型方法继承到另一个构造函数中。constructor构造函数的原型将被设置为使用superConstructor构造函数所创建的一个新对象。</p>
<p>此方法带来的额外的好处是，可以通过constructor.super_属性来访问superConstructor构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyStream, events.EventEmitter);</span><br><span class="line"></span><br><span class="line">MyStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">"data"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> MyStream();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stream <span class="keyword">instanceof</span> events.EventEmitter); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(MyStream.super_ === events.EventEmitter); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received data: "'</span> + data + <span class="string">'"'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">stream.write(<span class="string">"It works!"</span>); <span class="comment">// Received data: "It works!"</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/10/nodejs-note-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/10/nodejs-note-process/" itemprop="url">Node.js学习笔记——process 进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-10T00:00:00+08:00">2011-12-10</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node-js/" itemprop="url" rel="index">
                    <span itemprop="name">node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>process对象是一个全局对象，可以在任何地方访问它。</p>
<p>它是EventEmitter事件触发器类型的一个实例。</p>
<h3 id="Event-‘exit’-事件：’exit’"><a href="#Event-‘exit’-事件：’exit’" class="headerlink" title="Event: ‘exit’ 事件：’exit’"></a>Event: ‘exit’ 事件：’exit’</h3><p>当进程对象要退出时会触发此方法，这是检查模块状态（比如单元测试）的好时机。当’exit’被调用完成后主事件循环将终止，所以计时器将不会按计划执行。</p>
<p>监听exit行为的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'This will not run'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'About to exit.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Event-‘uncaughtException’-事件：’uncaughtException’"><a href="#Event-‘uncaughtException’-事件：’uncaughtException’" class="headerlink" title="Event: ‘uncaughtException’ 事件：’uncaughtException’"></a>Event: ‘uncaughtException’ 事件：’uncaughtException’</h3><p>function (err) { }</p>
<p>当一个异常信息一路冒出到事件循环时，该方法被触发。如果该异常有一个监听器，那么默认的行为（即打印一个堆栈轨迹并退出）将不会发生。</p>
<p>监听uncaughtException事件的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Caught exception: '</span> + err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'This will still run.'</span>);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Intentionally cause an exception, but don't catch it.</span></span><br><span class="line">nonexistentFunc();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'This will not run.'</span>);</span><br></pre></td></tr></table></figure></p>
<p>注意：就异常处理来说，uncaughtException是一个很粗糙的机制。在程序中使用try/catch可以更好好控制程序流程。而在服务器编程中，因为要持续运行，uncaughtException还是一个很有用的安全机制。</p>
<h3 id="Signal-Events-信号事件"><a href="#Signal-Events-信号事件" class="headerlink" title="Signal Events 信号事件"></a>Signal Events 信号事件</h3><p>该事件会在进程接收到一个信号时被触发。可参见sigaction(2)中的标准POSIX信号名称列表，比如SIGINT，SIGUSR1等等。</p>
<p>监听 SIGINT的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start reading from stdin so we don't exit.</span></span><br><span class="line">process.stdin.resume();</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'SIGINT'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Got SIGINT.  Press Control-D to exit.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在大多数终端程序中，一个简易发送SIGINT信号的方法是在使用Control-C命令操作。</p>
<h3 id="process-stdout"><a href="#process-stdout" class="headerlink" title="process.stdout"></a>process.stdout</h3><p>一个指向标准输出stdout的Writable Stream可写流。</p>
<p>示例：console.log的定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">    process.stdout.write(d + <span class="string">'\n'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="process-stderr"><a href="#process-stderr" class="headerlink" title="process.stderr"></a>process.stderr</h3><p>一个指向错误的可写流，在这个流上的写操作是阻塞式的。</p>
<h3 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a>process.stdin</h3><p>一个到标准输入的可读流Readable Stream。默认情况下标准输入流是暂停的，要从中读取内容需要调用方法process.stdin.resume()。</p>
<p>示例：打开标准输入与监听两个事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.resume();</span><br><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    process.stdout.write(<span class="string">'end'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h3><p>一个包含命令行参数的数组。第一个元素是’node’，第二个元素是JavaScript文件的文件名。接下来的元素则是附加的命令行参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print process.argv</span></span><br><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index + <span class="string">': '</span> + val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这产生如下的信息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node process<span class="number">-2.</span>js one two=three four</span><br><span class="line"><span class="number">0</span>: node</span><br><span class="line"><span class="number">1</span>: <span class="regexp">/Users/m</span>jr/work/node/process<span class="number">-2.</span>js</span><br><span class="line"><span class="number">2</span>: one</span><br><span class="line"><span class="number">3</span>: two=three</span><br><span class="line"><span class="number">4</span>: four</span><br></pre></td></tr></table></figure></p>
<h3 id="process-execPath"><a href="#process-execPath" class="headerlink" title="process.execPath"></a>process.execPath</h3><p>这是一个启动该进程的可执行程序的绝对路径名。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/node</span><br></pre></td></tr></table></figure></p>
<h3 id="process-chdir-directory"><a href="#process-chdir-directory" class="headerlink" title="process.chdir(directory)"></a>process.chdir(directory)</h3><p>改变进程的当前工作目录，如果操作失败则抛出异常。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Starting directory: '</span> + process.cwd());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.chdir(<span class="string">'/tmp'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New directory: '</span> + process.cwd());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'chdir: '</span> + err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h3><p>返回进程的当前工作目录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Current directory: '</span> + process.cwd());</span><br></pre></td></tr></table></figure>
<h3 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h3><p>一个包括用户环境的对象。可参见environ(7)。</p>
<h3 id="process-exit-code-0"><a href="#process-exit-code-0" class="headerlink" title="process.exit(code=0)"></a>process.exit(code=0)</h3><p>用指定的code代码结束进程。如果不指定，退出时将使用’success’（成功）代码 0。</p>
<p>以’failure’（失败）代码退出的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.exit(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>执行node的shell会把退出代码视为1。</p>
<h3 id="process-getgid"><a href="#process-getgid" class="headerlink" title="process.getgid()"></a>process.getgid()</h3><p>获取进程的群组标识（详见getgid(2)）。这是一个数字的群组ID，不是群组名称。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Current gid: '</span> + process.getgid());</span><br></pre></td></tr></table></figure></p>
<h3 id="process-setgid-id"><a href="#process-setgid-id" class="headerlink" title="process.setgid(id)"></a>process.setgid(id)</h3><p>设置进程的群组标识（详见getgid(2)）。参数可以是一个数字ID或者群组名字符串。如果指定了一个群组名，这个方法会阻塞等待将群组名解析为数字ID。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Current gid: '</span> + process.getgid());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.setgid(<span class="number">501</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New gid: '</span> + process.getgid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Failed to set gid: '</span> + err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="process-getuid"><a href="#process-getuid" class="headerlink" title="process.getuid()"></a>process.getuid()</h3><p>获取进程的用户ID（详见getgid(2)）。这是一个数字用户ID，不是用户名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Current uid: '</span> + process.getuid());</span><br></pre></td></tr></table></figure>
<h3 id="process-setuid-id"><a href="#process-setuid-id" class="headerlink" title="process.setuid(id)"></a>process.setuid(id)</h3><p>设置进程的用户ID（详见getgid(2)）。参数可以使一个数字ID或者用户名字符串。如果指定了一个用户名，那么该方法会阻塞等待将用户名解析为数字ID。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Current uid: '</span> + process.getuid());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.setuid(<span class="number">501</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New uid: '</span> + process.getuid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Failed to set uid: '</span> + err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="process-version"><a href="#process-version" class="headerlink" title="process.version"></a>process.version</h3><p>一个编译内置的属性，用于显示NODE_VERSION（Node版本）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Version: '</span> + process.version);</span><br></pre></td></tr></table></figure>
<h3 id="process-installPrefix"><a href="#process-installPrefix" class="headerlink" title="process.installPrefix"></a>process.installPrefix</h3><p>一个编译内置的属性，用于显示NODE_PREFIX（Node安装路径前缀）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Prefix: '</span> + process.installPrefix);</span><br></pre></td></tr></table></figure>
<h3 id="process-kill-pid-signal-’SIGTERM’"><a href="#process-kill-pid-signal-’SIGTERM’" class="headerlink" title="process.kill(pid, signal=’SIGTERM’)"></a>process.kill(pid, signal=’SIGTERM’)</h3><p>发送一个信号到进程。pid是进程的ID，参数signal是欲发送信号的字符串描述。信号名称是像’SIGINT’或者’SIGUSR1’这样的字符串。如果参数signal忽略，则信号为’SIGTERM’。详见kill(2)。</p>
<p>注意该函数名为process.kill，实际上也就像kill系统调用一样仅仅是一个信号发送器。发送的信号可能是要终止目标进程，也可能是实现其他不同的目的。</p>
<p>一个给自己发送信号的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGHUP'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Got SIGHUP signal.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Exiting.'</span>);</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">process.kill(process.pid, <span class="string">'SIGHUP'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="process-pid"><a href="#process-pid" class="headerlink" title="process.pid"></a>process.pid</h3><p>进程的PID。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'This process is pid '</span> + process.pid);</span><br></pre></td></tr></table></figure>
<h3 id="process-title"><a href="#process-title" class="headerlink" title="process.title"></a>process.title</h3><p>获取或设置在’ps’命令中显示的进程的标题。</p>
<h3 id="process-platform"><a href="#process-platform" class="headerlink" title="process.platform"></a>process.platform</h3><p>运行Node的平台信息，如’linux2’，’darwin’`等等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'This platform is '</span> + process.platform);</span><br></pre></td></tr></table></figure></p>
<h3 id="process-memoryUsage"><a href="#process-memoryUsage" class="headerlink" title="process.memoryUsage()"></a>process.memoryUsage()</h3><p>返回一个描述Node进程内存使用情况的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(process.memoryUsage()));</span><br></pre></td></tr></table></figure>
<p>这会生成如下信息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">rss</span>: <span class="number">4935680</span>,</span><br><span class="line">  vsize: <span class="number">41893888</span>,</span><br><span class="line">  heapTotal: <span class="number">1826816</span>,</span><br><span class="line">  heapUsed: <span class="number">650472</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>heapTotal与heapUsed指V8的内存使用情况。</p>
<h3 id="process-nextTick-callback"><a href="#process-nextTick-callback" class="headerlink" title="process.nextTick(callback)"></a>process.nextTick(callback)</h3><p>在事件循环的下一次循环中调用callback回调函数。这不是setTimeout(fn, 0)的一个别名，因为它有效率多了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick callback'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="process-umask-mask"><a href="#process-umask-mask" class="headerlink" title="process.umask([mask])"></a>process.umask([mask])</h3><p>设置或者读取进程的文件模式创建掩码。子进程从父进程中继承这个掩码。如果设定了参数mask那么返回旧的掩码，否则返回当前的掩码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldmask, newmask = <span class="number">0644</span>;</span><br><span class="line"></span><br><span class="line">oldmask = process.umask(newmask);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Changed umask from: '</span> + oldmask.toString(<span class="number">8</span>) + <span class="string">' to '</span> + newmask.toString(<span class="number">8</span>));</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/09/nodejs-note-modules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/09/nodejs-note-modules/" itemprop="url">Node.js学习笔记——Modules 模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-09T00:00:00+08:00">2011-12-09</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Node使用CommonJS模块系统。Node有一个简单的模块装载系统，在Node中，文件和模块是一一对应的。下面的例子展示了foo.js文件如何在相同的目录中加载circle.js模块。</p>
<p>foo.js的内容为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'The area of a circle of radius 4 is '</span> + circle.area(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>circle.js的内容为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PI = <span class="built_in">Math</span>.PI;</span><br><span class="line"></span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>circle.js模块输出了area()和circumference()两个函数，为了以对象的形式输出，需将要输出的函数加入到一个特殊的exports对像中。</p>
<p>模块的本地变量是私有的。在上面的例子中，变量PI就是circle.js私有的。</p>
<p>###Core Modules 核心模块###</p>
<p>Node有一些编译成二进制的模块。</p>
<p>核心模块在node源代码中的lib文件夹下。</p>
<p>核心模块总是被优先加载，如果它们的标识符被require()调用。例如，require(‘http’)将总是返回内建的HTTP模块，即便又一个同名文件存在。</p>
<p>###File Modules 文件模块###</p>
<p>如果没有找到确切的文件名，node将尝试以追加扩展名.js后的文件名读取文件，如果还是没有找到则尝试追加扩展名.node。.js文件被解释为JavaScript格式的纯文本文件，.node文件被解释为编译后的addon（插件）模块，并使用dlopen来加载。</p>
<p>以’/‘为前缀的模块是一个指向文件的绝对路径，例如require(‘/home/marco/foo.js’)将加载文件/home/marco/foo.js。</p>
<p>如果标明一个文件时没有 ‘/‘ 或 ‘./‘前缀，该模块或是”核心模块”，或者位于 node_modules目录中。</p>
<p>###Loading from ‘node_modules’ Folders 从 ‘node_modules’ 目录中加载###</p>
<p>如果传递到 require()的模块标识符不是一个核心模块，并且不是以’/‘，’../‘或’./‘开头，node将从当前模块的父目录开始，在其/node_modules子目录中加载该模块。</p>
<p>如果在那里没有找到，就转移到上一级目录，依此类推，直到找到该模块或到达目录树的根结点。</p>
<p>例如，如果在文件 ‘/home/ry/projects/foo.js’中调用 `require(‘bar.js’)，node将会依次查找以下位置：</p>
<ul>
<li>/home/ry/projects/node_modules/bar.js</li>
<li>/home/ry/node_modules/bar.js</li>
<li>/home/node_modules/bar.js</li>
<li>/node_modules/bar.js</li>
</ul>
<p>这允许程序本地化他们的依赖关系，避免发生冲突。</p>
<p>###Optimizations to the ‘node_modules’ Lookup Process 优化 ‘node_modules’ 的查找过程###</p>
<p>如果有很多级的嵌套信赖，文件树会变得相当的长，下面是对这一过程的一些优化。</p>
<p>首先， /node_modules不要添加到以 /node_modules结尾的目录上。</p>
<p>其次，如果调用require()的文件已经位于一个node_modules层次中，最上级的node_modules目录将被作为搜索的根。</p>
<p>例如，如果文件’/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js’调用require(‘asdf.js’)，node会在下面的位置进行搜索：</p>
<ul>
<li>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/asdf.js</li>
<li>/home/ry/projects/foo/node_modules/bar/node_modules/asdf.js</li>
<li>/home/ry/projects/foo/node_modules/asdf.js</li>
</ul>
<p>###Folders as Modules 目录作为模块###</p>
<p>很方便将程序或库组织成自包含的目录，并提供一个单独的入口指向那个库。有三种方式可以将一个子目录作为参数传递给 require() </p>
<p>第一种方法是在目录的根下创建一个名为package.json的文件，它指定了一个main 模块。一个package.jso文件的例子如下面所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"name"</span> : <span class="string">"some-library"</span>,</span><br><span class="line">  <span class="string">"main"</span> : <span class="string">"./lib/some-library.js"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果此文件位于./some-library目录中，require(‘./some-library’)将试图加载文件./some-library/lib/some-library.js。</p>
<p>这是Node感知package.json文件的范围。</p>
<p>如果在目录中没有package.json文件，node将试图在该目录中加载index.js 或 index.node文件。例如，在上面的例子中没有 package.json文件，require(‘./some-library’)将试图加载：</p>
<ul>
<li>./some-library/index.js</li>
<li>./some-library/index.node</li>
</ul>
<p>###Caching 缓存###</p>
<p>模块在第一次加载后将被缓存。这意味着（类似其他缓存）每次调用require(‘foo’)如果解析到相同的文件，那么将返回同一个对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2011/12/08/nodejs-note-timers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SpeMoon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人在江湖漂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2011/12/08/nodejs-note-timers/" itemprop="url">Node.js学习笔记——Timers 定时器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-12-08T00:00:00+08:00">2011-12-08</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节内容与原生js类似。</p>
<h3 id="setTimeout-callback-delay-arg-…"><a href="#setTimeout-callback-delay-arg-…" class="headerlink" title="setTimeout(callback, delay, [arg], […])"></a>setTimeout(callback, delay, [arg], […])</h3><p>设定一个delay毫秒后执行callback回调函数的计划。返回值timeoutId可被用于clearTimeout()。可以设定要传递给回调函数的参数。</p>
<h3 id="clearTimeout-timeoutId"><a href="#clearTimeout-timeoutId" class="headerlink" title="clearTimeout(timeoutId)"></a>clearTimeout(timeoutId)</h3><p>清除定时器，阻止指定的timeout（超时）定时器被触发。</p>
<h3 id="setInterval-callback-delay-arg-…"><a href="#setInterval-callback-delay-arg-…" class="headerlink" title="setInterval(callback, delay, [arg], […])"></a>setInterval(callback, delay, [arg], […])</h3><p>设定一个每delay毫秒重复执行callback回调函数的计划。返回值intervalId可被用于clearInterval()。可以设定要传递给回调函数的参数。</p>
<h3 id="clearInterval-intervalId"><a href="#clearInterval-intervalId" class="headerlink" title="clearInterval(intervalId)"></a>clearInterval(intervalId)</h3><p>清除定时器，阻止指定的interval（间隔）定时器被触发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">SpeMoon</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SpeMoon</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
